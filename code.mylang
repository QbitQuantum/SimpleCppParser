
using pointer ERequestError = function[void][__fastcall(__closure*)](TNetHTTPClient*, string Link, LLinkWorkType, string Error);
using pointer ERequestEvent = function[void][__fastcall(__closure*)](TNetHTTPClient*, string Link, LLinkWorkType);
using pointer ERequestObtainData = function[void][__fastcall(__closure*)](TObject*, string Data, int Arg);

using type string = System::UnicodeString;
using type w_string = System::WideString;

using access BaseRequest = OctetBaseLink::OctetBaseLinkRequest;
using access LinkConnection = link::connection;
using access LinkResponse = link::response;
using access LinkType = link::type;

var[const int] INDEX_INVALID = -1;
// base link class
class OctetBaseLink : OctetBaseNode {

private:

    // async request class
    class OctetBaseLinkRequest : TNetHTTPRequest {

    private:
        type[string] __link;
        var[OctetBaseLink*] __parent;
        var[bool] __abort = false;
        var[int] __arg = INDEX_INVALID;

        function[void][__fastcall] _eventerror(TObject* const, const string);
        function[void][__fastcall] _eventcomplete(TObject* const, const _di_IHTTPResponse);
        function[void][__fastcall] _eventreceive(TObject* const, __int64 AContentLength, __int64 AReadCount, bool& Abort);

    public:

        type[string] RequestTag;
        pointer[ERequestObtainData] OnObtainData = nullptr;
        var[bool] Completed = false;

        __property[string] Link = { __link };

        function[void][__fastcall] Get();
        function[void][__fastcall] Abort();

        function[void][__fastcall] OctetBaseLinkRequest(OctetBaseLink*, string RequestTag, string Link, ERequestObtainData, int Argument = INDEX_INVALID);
    };

protected:

    // internal data
    function[bool][__fastcall] _start(LLinkWorkType, string);

    var[TNetHTTPClient*] __client = nullptr, __asyncclient = nullptr;
    var[LLinkWorkType] __work = lwIdle;

    type[string] __host, __lastresult;

    var[int] 
        __contime = access[LinkConnection] timeout, 
        __restime = access[LinkResponse] timeout;

    var[int] 
        __contimeasync = access[LinkConnection] timeout_async, 
        __restimeasync = access[LinkResponse] timeout_async;
    var[int] 
        __lastcode = access[LinkResponse] timeout;

    // class init
    function[void][__fastcall] _init();

    // header methods
    function[void][__fastcall] _setheaders(TNetHTTPClient*, bool State);

    // internal events
    function[void][__fastcall] _eventerror(TObject* const, const string);
    function[void][__fastcall] _eventcomplete(TObject* const, const _di_IHTTPResponse);
    function[void][__fastcall] _eventauth(TObject* const, TAuthTargetType Target, const string, const string, string&, string&, bool&, TAuthPersistenceType&);

static:
    function[void][__fastcall] _eventexecute(TObject* const, const string);

public:

    // variables
    type[string] DefaultLink, UpdateLink, UserIdent, MachineIdent;

    var[bool] LocalLinking = false, InputCache = false, OutputCache = false;

    // events
    pointer[ERequestEvent] OnStart = nullptr, OnComplete = nullptr;
    pointer[ERequestError] OnError = nullptr;

    // base network methods

    function[string][__fastcall] Read(string, int Type = access[LinkType] critical);
    function[void][__fastcall] Read(string, ERequestObtainData, string RequestTag, int Argument = INDEX_INVALID);
    function[void][__fastcall] Cache(string Link, ERequestObtainData Event, string RequestTag, int Argument = INDEX_INVALID);
    function[string][__fastcall] Cache(string Link);
    function[void][__fastcall] Stop(string RequestTag = "");
    function[bool][__fastcall] Write(string, string Data, TStringStream* Response = NULL);
    function[void][__fastcall] Write(string, string, ERequestObtainData Event, string RequestTag, int Argument = INDEX_INVALID);
    function[bool][__fastcall] Delete(string);
    function[bool][__fastcall] Auth(string, string User, string Pass, TStringStream* Response = NULL);
    function[string][__fastcall] ResponseCode();
    function[string][__fastcall] ResponseCode(int, string);
    function[void][__fastcall] ClearCache(int AgeDays);
    function[string][__fastcall] ClearCache(bool Download) {
        
        ResponseCode();

        if (__client)
        {   __client->Method(); };

        var[double] d = 3.14;

        type[string] str = "string moment";
        type[w_string] w_str = l"string moment";

        var[char] ch = 'A';
        var[wchar_t] w_ch = l'A';

        var[int] i =  static_cast<int>(d);  // Преобразование double в int

        var[Base*] basePtr = new Derived();
        var[Derived*] derivedPtr = dynamic_cast<Derived*>(basePtr); // Безопасное приведение к Derived
        delete basePtr;

        var[const double] c = 3.14;

        var[int] number = 65;
        var[char*] charPtr = reinterpret_cast<char*>(&number);

        // var[auto] param = "Download";
        type[string] param = "Download";

        if (Download)
        {
            param += " true";
        }
        else
        {
            param = " false";
        };
        return param;
    };

    // properties
    __property[TNetHTTPClient*] Client = { __asyncclient };
    __property[int] ConnectionTimeout = { __contime };
    __property[int] ResponseTimeout = { __restime };
    __property[int] ConnectionTimeoutAsync = { __contimeasync };
    __property[int] ResponseTimeoutAsync = { __restimeasync };
    __property[int] LastResponseCode = { __lastcode, __lastcode };
    __property[int] ConnectionHost = { __host };
    __property[int] ConnectionTask = { nullptr, __host };

    function[void][__fastcall] OctetBaseLink(
        TComponent*, 
        int ConnectionTimeout = access[LinkConnection] timeout, 
        int ResponseTimeout = access[LinkResponse] timeout, 
        int ConnectionTimeoutAsync = access[LinkConnection] timeout_async, 
        int ResponseTimeoutAsync = access[LinkResponse] timeout_async);
};

// function[void][__fastcall] OctetBaseLink::OctetBaseLinkRequest::Abort()  {
function[void][__fastcall] access[BaseRequest] Abort()  {
    var[const int] number = 1;
};

class Base<T, K> : Derive<T> {
    function[T][__fastcall] Stop(K RequestTag);
    var[K] Data;
    var[K*] PointData = nullptr;
};

class Base {

public:
    var[int] PublicBaseData;
    function[void] [virtual] PublicMethodBase() { };
    function[void] [] Base() { };
static:
    var[int] StaticBaseData;
    function[void][] StaticMethodBase() { };
}

class Derived : Base {

public:
    function[void] [override] PublicMethodBase() { };
    function[void] [] Derived() { };
    class Math {
    static:
        function[void] [] PublicMethodBase() { };
    }
static:
    var[int] StaticData = 1;
    function[void][] StaticMethodBase() { };

private:
    var[int] m_pivate = 1;

}

function[void] [] PublicMethodBase() { };

function[int][] main () {
    
    var[Derived*] un = new Derived();

    PublicMethodBase();            // текущий контекст -> глобальный
    Derived::StaticMethodBase();       // статический
    Derived::Math::PublicMethodBase(); // статический вложенного класса
    
    un.PublicMethodBase();           // Объект напрямую
    un->PublicMethodBase();          // виртуальный через указатель  
        
    delete un;
    return 0;
};

/*
function[int][] main (var[int] argc, var[char*] argv) {
    return 0;
};

function[int][] main () {
    
    return int(); // Равен хз, ну пускай -1;
};
*/