#include "math.mylang"
#include "utils"
#include "math.txt"
#include <vector>

var[const int] INDEX_INVALID = i"-1"; // Для отрицательных чисел заключаем в "" с суффиксом i

using ERequestError = function[void][__fastcall(__closure*)](TNetHTTPClient*, string Link, LLinkWorkType, string Error);
using ERequestEvent = function[void][__fastcall(__closure*)](TNetHTTPClient*, string Link, LLinkWorkType);
using ERequestObtainData = function[void][__fastcall(__closure*)](TObject*, string Data, int Arg);

// base link class
class OctetBaseLink : OctetBaseNode {

private:

    // async request class
    class OctetBaseLinkRequest : TNetHTTPRequest {

    private:
        var[string] __link;
        var[OctetBaseLink*] __parent;
        var[bool] __abort = false;
        var[int] __arg = INDEX_INVALID;

        function[void][__fastcall] _eventerror(TObject* const, const string);
        function[void][__fastcall] _eventcomplete(TObject* const, const _di_IHTTPResponse);
        function[void][__fastcall] _eventreceive(TObject* const, __int64 AContentLength, __int64 AReadCount, bool& Abort);

    public:

        var[string] RequestTag;
        pointer[ERequestObtainData] OnObtainData = nullptr;
        var[bool] Completed = false;

        __property string Link = { __link };

        function[void][__fastcall] Get();
        function[void][__fastcall] Abort();

        function[void][__fastcall] OctetBaseLinkRequest(OctetBaseLink*, string RequestTag, string Link, ERequestObtainData, int Argument = INDEX_INVALID);
    };

protected:

    // internal data
    function[bool][__fastcall] _start(LLinkWorkType, string);

    var[TNetHTTPClient*] __client = nullptr, __asyncclient = nullptr;
    var[LLinkWorkType] __work = lwIdle;

    var[string] __host, __lastresult;

    var[int] 
        __contime = access[link::connection] timeout, 
        __restime = access[link::response] timeout;

    var[int] 
        __contimeasync = access[link::connection] timeout_async, 
        __restimeasync = access[link::response] timeout_async;
    var[int] 
        __lastcode = access[link::response] timeout;

    // class init
    function[void][__fastcall] _init();

    // header methods
    function[void][__fastcall] _setheaders(TNetHTTPClient*, bool State);

    // internal events
    function[void][__fastcall] _eventerror(TObject* const, const string);
    function[void][__fastcall] _eventcomplete(TObject* const, const _di_IHTTPResponse);
    function[void][__fastcall] _eventauth(TObject* const, TAuthTargetType Target, const string, const string, string&, string&, bool&, TAuthPersistenceType&);

static:
    function[void][__fastcall] _eventexecute(TObject* const, const string);

public:

    // variables
    var[string] DefaultLink, UpdateLink, UserIdent, MachineIdent;

    var[bool] LocalLinking = false, InputCache = false, OutputCache = false;

    // events
    pointer[ERequestEvent] OnStart = nullptr, OnComplete = nullptr;
    pointer[ERequestError] OnError = nullptr;

    // base network methods

    function[string][__fastcall] Read(string, int Type = access[link::type] critical);
    function[void][__fastcall] Read(string, ERequestObtainData, string RequestTag, int Argument = INDEX_INVALID);
    function[void][__fastcall] Cache(string Link, ERequestObtainData Event, string RequestTag, int Argument = INDEX_INVALID);
    function[string][__fastcall] Cache(string Link);
    function[void][__fastcall] Stop(string RequestTag = "");
    function[bool][__fastcall] Write(string, string Data, TStringStream* Response = NULL);
    function[void][__fastcall] Write(string, string, ERequestObtainData Event, string RequestTag, int Argument = INDEX_INVALID);
    function[bool][__fastcall] Delete(string);
    function[bool][__fastcall] Auth(string, string User, string Pass, TStringStream* Response = NULL);
    function[string][__fastcall] ResponseCode();
    function[string][__fastcall] ResponseCode(int, string);
    function[void][__fastcall] ClearCache(int AgeDays);
    function[string][__fastcall] ClearCache(bool Download) {
        
        call access[This] ResponseCode();

        if (__client)
        {    call access[This] __client->Method(); };

        var[double] d = 3.14;

        var[string] str = "string moment";
        var[w_string] w_str = l"string moment";

        var[char] ch = 'A';
        var[w_char] w_ch = l'A';

        var[int] i = call static_cast<int>(d);  // Преобразование double в int

        var[Base*] basePtr = call access[] new Derived();
        var[Derived*] derivedPtr = call access[] dynamic_cast<Derived*>(basePtr); // Безопасное приведение к Derived
        call access[] delete basePtr;

        var[const double] c = 3.14;

        var[int] number = 65;
        var[char*] charPtr = call access[] reinterpret_cast<char*>(&number);

        // var[auto] param = "Download";
        var[string] param = "Download";

        if (Download)
        {
            param += " true";
        }
        else
        {
            param = " false";
        };
        return param;
    };

    // properties
    __property TNetHTTPClient* Client = { __asyncclient };
    __property int ConnectionTimeout = { __contime };
    __property int ResponseTimeout = { __restime };
    __property int ConnectionTimeoutAsync = { __contimeasync };
    __property int ResponseTimeoutAsync = { __restimeasync };
    __property int LastResponseCode = { __lastcode, __lastcode };
    __property int ConnectionHost = { __host };
    __property int ConnectionTask = { nullptr, __host };

    function[void][__fastcall] OctetBaseLink(
        TComponent*, 
        int ConnectionTimeout = access[link::connection] timeout, 
        int ResponseTimeout = access[link::response] timeout, 
        int ConnectionTimeoutAsync = access[link::connection] timeout_async, 
        int ResponseTimeoutAsync = access[link::response] timeout_async);
};

function[void][__fastcall] access[OctetBaseLink::OctetBaseLinkRequest] Abort()  {
    var[const int] number = 1;
};

class Base<T, K> : Derive<T> {
    function[T][__fastcall] Stop(K RequestTag);
    var[K] Data;
    var[K*] PointData = nullptr;
};

class Base {

public:
    var[int] PublicBaseData;
    function[void] [virtual] PublicMethodBase() { };
    function[void] [] Base() { };
static:
    var[int] StaticBaseData;
    function[void][] StaticMethodBase() { };
}

class Derived : Base {

public:
    function[void] [override] PublicMethodBase() { };
    function[void] [] Derived() { };
    class Math {
    static:
        function[void] [] PublicMethodBase() { };
    }
static:
    var[int] StaticData = 1;
    function[void][] StaticMethodBase() { };

private:
    var[int] m_pivate = 1;

}

function[void] [] PublicMethodBase() { };

function[int][] main () {
    
    var[Derived*] un = call access[] new Derived();

    call access[] PublicMethodBase();                    // глобальный
    call access[This] PublicMethodBase();                    // текущий контекс
    call access[Derived] StaticMethodBase();          // статический
    call access[Derived::Math] PublicMethodBase();    // статический вложенного класса
    
    call access[This] un.PublicMethodBase();                 // Объект напрямую
    call access[This] un=>PublicMethodBase();               // явный вызов базовой версии 
    call access[This] un->PublicMethodBase();               // виртуальный через указатель  
        
    call access[] delete un;
    return 0;
};

/*
function[int][] main (var[int] argc, var[char*] argv) {
    return 0;
};

function[int][] main () {
    
    return call int(); // Равен хз, ну пускай -1;
};
*/